<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>叉音詞語賽車遊戲 (Cantonese Racing v14 - Final Fix)</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #2b4d2c;
            font-family: "Microsoft JhengHei", "Heiti TC", sans-serif;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            background: repeating-linear-gradient(45deg, #2b4d2c, #2b4d2c 20px, #355e37 20px, #355e37 40px);
        }

        canvas {
            background-color: #555;
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
            border-left: 5px solid #7f8c8d;
            border-right: 5px solid #7f8c8d;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #crash-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; pointer-events: none; transition: opacity 0.2s;
            z-index: 5;
        }

        #hud {
            padding: 15px 20px;
            color: white; font-size: 20px; font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            display: flex; justify-content: space-between;
            width: 90%; margin: 0 auto;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0) 100%);
        }

        #progress-wrapper {
            position: absolute; top: 60px; left: 50%; transform: translateX(-50%);
            width: 80%; text-align: center; color: white; font-weight: bold;
            text-shadow: 1px 1px 2px black;
        }

        #progress-container {
            width: 100%; height: 15px; background: rgba(0,0,0,0.6);
            border-radius: 10px; border: 2px solid rgba(255,255,255,0.5);
            overflow: hidden; margin-top: 5px;
        }

        #progress-fill {
            height: 100%; background: linear-gradient(90deg, #FFD700, #FF8C00);
            width: 0%; transition: width 0.5s ease-out;
        }

        .menu-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; color: white; z-index: 20;
        }

        h1 { font-size: 2.5rem; margin: 0 0 20px 0; text-align: center; color: #FFD700; text-shadow: 3px 3px 0 #000;}
        p { font-size: 1.2rem; margin-bottom: 30px; text-align: center; max-width: 600px; }

        .car-selector {
            display: flex; gap: 20px; margin-bottom: 30px;
            background: rgba(255,255,255,0.1); padding: 20px; border-radius: 15px;
        }

        .car-btn {
            width: 50px; height: 80px; border-radius: 8px; cursor: pointer;
            transition: transform 0.2s; border: 3px solid transparent; position: relative;
        }
        .car-btn::before, .car-btn::after { content: ''; position: absolute; width: 6px; height: 14px; background: #222; border-radius: 2px; left: -6px; }
        .car-btn::before { top: 10px; box-shadow: 56px 0 0 #222; }
        .car-btn::after { bottom: 10px; box-shadow: 56px 0 0 #222; }
        .car-btn:hover, .car-btn.selected { transform: scale(1.1); border-color: #FFD700; box-shadow: 0 0 15px #FFD700; }

        button.start-btn {
            padding: 15px 50px; font-size: 24px;
            background: linear-gradient(to bottom, #FFD700, #FFA500);
            border: none; border-radius: 50px; cursor: pointer;
            font-weight: bold; color: #333; box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        button.start-btn:active { transform: scale(0.95); }

        #therapist-btn {
            pointer-events: auto; 
            background: linear-gradient(to bottom, #4CAF50, #2E7D32);
            border: 3px solid white; 
            color: white;
            font-size: 22px; 
            font-weight: bold; 
            padding: 15px 50px;
            border-radius: 50px; 
            box-shadow: 0 5px 20px rgba(0,0,0,0.5); 
            display: none;
            position: absolute;
            top: 52%; 
            left: 50%;
            transform: translate(-50%, 0);
            z-index: 50;
        }

        #current-word-display {
            position: absolute; 
            top: 35%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            font-size: 90px; color: #FFD700; font-weight: 900;
            text-shadow: 5px 5px 0px #000, -2px -2px 0 #333;
            display: none; z-index: 15;
            background: rgba(0,0,0,0.8); padding: 30px 60px;
            border-radius: 25px; border: 6px solid white; white-space: nowrap;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="crash-overlay"></div>
        
        <div id="ui-layer">
            <div id="hud" class="hidden">
                <span>第 <span id="round-num">1</span> 回合</span>
                <span>分數: <span id="score">0</span></span>
            </div>
            
            <div id="progress-wrapper" class="hidden">
                <span id="progress-text">0 / 5</span>
                <div id="progress-container">
                    <div id="progress-fill"></div>
                </div>
            </div>

            <div id="current-word-display"></div>
            <button id="therapist-btn">正確 (Correct)</button>
        </div>

        <div id="start-screen" class="menu-screen">
            <h1>叉音詞語賽車遊戲</h1>
            <p>請選擇你的賽車</p>
            <div class="car-selector" id="start-car-selector">
                <div class="car-btn" style="background:#333;" onclick="selectCar('#333', this)"></div>
                <div class="car-btn" style="background:#2ecc71;" onclick="selectCar('#2ecc71', this)"></div>
                <div class="car-btn" style="background:#3498db;" onclick="selectCar('#3498db', this)"></div>
                <div class="car-btn selected" style="background:#e74c3c;" onclick="selectCar('#e74c3c', this)"></div>
            </div>
            <p style="font-size: 0.9rem; opacity: 0.8;">
                控制: A/D 或 左右滑動<br>
                移動賽車收集字卡!
            </p>
            <button class="start-btn" onclick="startGame()">開始遊戲</button>
        </div>

        <div id="round-screen" class="menu-screen hidden">
            <h1 id="round-title">回合完成!</h1>
            <p>下一回合前，你可以更換車輛:</p>
            <div class="car-selector" id="round-car-selector">
                <div class="car-btn" style="background:#333;" onclick="selectCar('#333', this)"></div>
                <div class="car-btn" style="background:#2ecc71;" onclick="selectCar('#2ecc71', this)"></div>
                <div class="car-btn" style="background:#3498db;" onclick="selectCar('#3498db', this)"></div>
                <div class="car-btn" style="background:#e74c3c;" onclick="selectCar('#e74c3c', this)"></div>
            </div>
            <button class="start-btn" onclick="nextRound()">下一回合</button>
        </div>

        <div id="end-screen" class="menu-screen hidden">
            <h1>恭喜完成!</h1>
            <p>最終分數: <span id="final-score">0</span></p>
            <button class="start-btn" onclick="location.reload()">再玩一次</button>
        </div>
    </div>

<script>
    // --- Configuration & Data ---
    const masterWordList = [
        "茶杯", "茶葉", "茶壺", "叉子", "刀叉", "踩到", "猜謎", "菜心", "生菜", "白菜",
        "出口", "才華", "車輛", "廁所", "廁紙", "村莊", "錯誤", "長笛", "草地", "小草",
        "穿衣", "超人", "早操", "操場", "炒飯", "炒蛋", "炒麵", "擦膠", "牆壁", "錢幣"
    ];

    const trafficColors = ['#95a5a6', '#f1c40f', '#e67e22', '#8e44ad', '#16a085'];
    const WORDS_PER_ROUND = 5;
    
    // --- Game Variables ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    let gameState = 'MENU';
    let score = 0;
    let selectedColor = '#e74c3c';
    let currentRound = 0;
    let roundWords = [];
    let roundWordIndex = 0;
    
    // Timer Variables
    let nextWordSpawnTime = 0;
    
    // Movement
    let playerLane = 1; 
    let playerY; 
    let laneWidth, roadX, roadWidth;
    let speed = 0;
    const MAX_SPEED = 10;
    const START_SPEED = 5;
    let currentX = 0; 
    let frameCount = 0;
    let wordsCollectedInRound = 0;
    
    // Objects
    let obstacles = [];
    let traffic = [];
    
    // Audio
    let audioCtx;
    let gameLoopRunning = false;

    // --- Initialization ---
    function resize() {
        canvas.width = Math.min(window.innerWidth, 500); 
        canvas.height = window.innerHeight;
        roadWidth = canvas.width * 0.95;
        roadX = (canvas.width - roadWidth) / 2;
        laneWidth = roadWidth / 3;
        playerY = canvas.height - 180;
    }
    window.addEventListener('resize', resize);
    if (!ctx.roundRect) ctx.roundRect = function(x, y, w, h, r) { ctx.fillRect(x,y,w,h); };
    resize();

    function selectCar(color, element) {
        selectedColor = color;
        document.querySelectorAll('.car-btn').forEach(btn => btn.classList.remove('selected'));
        element.classList.add('selected');

        const allBtns = document.querySelectorAll('.car-btn');
        allBtns.forEach(btn => {
            if (btn.style.background.includes(color) || 
               (color === '#333' && btn.style.background.includes('rgb(51, 51, 51)'))) { 
                btn.classList.add('selected');
            }
        });
    }

    function startGame() {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        document.getElementById('progress-wrapper').classList.remove('hidden');
        
        shuffleArray(masterWordList);
        score = 0;
        currentRound = 0;
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        if (!gameLoopRunning) {
            gameLoopRunning = true;
            gameLoop();
        }

        nextRound();
    }

    function nextRound() {
        currentRound++;
        const startIndex = (currentRound - 1) * WORDS_PER_ROUND;
        
        if (startIndex >= masterWordList.length) {
            endGame();
            return;
        }

        roundWords = masterWordList.slice(startIndex, startIndex + WORDS_PER_ROUND);
        roundWordIndex = 0;
        obstacles = [];
        traffic = [];
        frameCount = 0;
        playerLane = 1;
        currentX = roadX + laneWidth * 1.5;
        speed = START_SPEED;
        wordsCollectedInRound = 0;
        
        // Spawn first word quickly (2s) instead of waiting full cycle
        nextWordSpawnTime = Date.now() + 2000; 

        gameState = 'PLAYING';

        document.getElementById('round-screen').classList.add('hidden');
        document.getElementById('ui-layer').classList.remove('hidden');
        document.getElementById('round-num').innerText = currentRound;
        updateHUD();
    }

    // --- Core Logic ---
    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

    function update() {
        if (gameState !== 'PLAYING') return;

        frameCount++;
        if (speed < MAX_SPEED) speed += 0.02; 
        
        const targetX = roadX + (playerLane * laneWidth) + (laneWidth / 2);
        currentX += (targetX - currentX) * 0.15;

        // --- UPDATE OBSTACLES & FIX MISSED CARDS ---
        obstacles.forEach(obs => {
            obs.y += speed;
            
            // CRITICAL FIX: If card goes off screen, mark it passed
            // Otherwise round never ends if player misses it
            if (obs.y > canvas.height + 50 && !obs.passed && !obs.stopped) {
                obs.passed = true;
            }
        });

        updateTraffic();

        // --- TIME-BASED SPAWNING ---
        if (roundWordIndex < roundWords.length) {
            if (Date.now() > nextWordSpawnTime) {
                spawnObstacle();
            }
        } else {
            // End Round logic: Check if all 5 cards have either been collected or passed screen
            let allPassed = obstacles.every(o => o.passed && o.y > canvas.height);
            
            // Failsafe: If array has 5 items and the last one is way off screen, end it.
            if (obstacles.length === WORDS_PER_ROUND) {
                 const lastObj = obstacles[obstacles.length-1];
                 if (lastObj.y > canvas.height + 200) allPassed = true;
            }

            if (allPassed) {
                setTimeout(() => {
                    if(gameState === 'PLAYING') {
                        gameState = 'ROUND_END';
                        document.getElementById('round-screen').classList.remove('hidden');
                        document.getElementById('ui-layer').classList.add('hidden');
                    }
                }, 500);
            }
        }

        checkCollisions();
    }

    // --- TRAFFIC LOGIC ---
    function updateTraffic() {
        traffic.forEach(car => { car.y += (speed - car.speed); });
        traffic = traffic.filter(car => car.y < canvas.height + 200);

        if (traffic.some(t => t.y < 350)) return; // Space out cars

        const activeWord = obstacles.find(o => o.y > -500 && o.y < canvas.height + 200);
        
        let forbiddenLane = -1;
        let trafficLimit = 3; 

        if (activeWord) {
            forbiddenLane = activeWord.lane;
            trafficLimit = 2; 
        }

        if (traffic.length >= trafficLimit) return;

        if (Math.random() < 0.03) { 
             spawnTraffic(forbiddenLane);
        }
    }

    function spawnTraffic(forbiddenLane) {
        let availableLanes = [0, 1, 2];
        if (forbiddenLane !== -1) availableLanes = availableLanes.filter(l => l !== forbiddenLane);
        if (availableLanes.length === 0) return;

        const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];

        traffic.push({
            lane: lane,
            y: -300, 
            speed: START_SPEED + 1 + Math.random() * 2,
            color: trafficColors[Math.floor(Math.random() * trafficColors.length)]
        });
    }

    function spawnObstacle() {
        if (roundWordIndex >= roundWords.length) return;
        
        let availableLanes = [0, 1, 2];
        availableLanes = availableLanes.filter(lane => {
            return !traffic.some(car => car.lane === lane && car.y < 100 && car.y > -400);
        });

        if (availableLanes.length === 0) availableLanes = [0, 1, 2];
        const lane = availableLanes[Math.floor(Math.random() * availableLanes.length)];
        
        obstacles.push({
            word: roundWords[roundWordIndex],
            lane: lane,
            y: -300,
            passed: false,
            stopped: false
        });
        
        roundWordIndex++;

        // Schedule NEXT spawn (7-10 seconds dynamic)
        const randomDelay = 7000 + Math.random() * 3000; 
        nextWordSpawnTime = Date.now() + randomDelay;
    }

    function checkCollisions() {
        // Traffic
        for (let i = traffic.length - 1; i >= 0; i--) {
            let car = traffic[i];
            const carX = roadX + (car.lane * laneWidth) + (laneWidth/2);
            if (Math.abs(currentX - carX) < 45 && car.y > playerY - 85 && car.y < playerY + 85) {
                handleCrash(car);
                traffic.splice(i, 1); 
            }
        }

        // Word Stop
        for (let i = 0; i < obstacles.length; i++) {
            let obs = obstacles[i];
            if (!obs.passed && !obs.stopped) {
                if (obs.lane === playerLane) {
                    if (obs.y > playerY - 100 && obs.y < playerY) {
                        triggerStop(obs);
                        break;
                    }
                }
            }
        }
    }

    function handleCrash(car) {
        playSound('crash');
        score = Math.max(0, score - 5);
        updateHUD();
        const overlay = document.getElementById('crash-overlay');
        overlay.style.opacity = 0.5;
        setTimeout(() => overlay.style.opacity = 0, 200);
        speed = 2; 
    }

    function triggerStop(obstacle) {
        gameState = 'STOPPED';
        obstacle.stopped = true;
        const disp = document.getElementById('current-word-display');
        disp.innerText = obstacle.word;
        disp.style.display = 'block';
        disp.classList.remove('hidden');
        if(isTouchDevice()) document.getElementById('therapist-btn').style.display = 'block';
    }

    function resumeGame(success) {
        if (gameState !== 'STOPPED') return;

        if (success) {
            playSound('ding');
            score += 10;
            wordsCollectedInRound++;
        }

        document.getElementById('current-word-display').classList.add('hidden');
        document.getElementById('therapist-btn').style.display = 'none';

        const stoppedObs = obstacles.find(o => o.stopped);
        if (stoppedObs) {
            stoppedObs.stopped = false;
            stoppedObs.passed = true;
            stoppedObs.y = canvas.height + 200; 
        }

        updateHUD();
        gameState = 'PLAYING';
        speed = START_SPEED; 
    }

    function endGame() {
        gameState = 'END';
        document.getElementById('final-score').innerText = score;
        document.getElementById('end-screen').classList.remove('hidden');
        document.getElementById('ui-layer').classList.add('hidden');
    }

    function updateHUD() {
        document.getElementById('score').innerText = score;
        const progressPct = (wordsCollectedInRound / WORDS_PER_ROUND) * 100;
        document.getElementById('progress-fill').style.width = progressPct + "%";
        document.getElementById('progress-text').innerText = `${wordsCollectedInRound} / ${WORDS_PER_ROUND}`;
    }

    // --- Rendering ---
    function draw() {
        ctx.clearRect(0,0,canvas.width, canvas.height);

        // Road
        ctx.fillStyle = "#545e6e";
        ctx.fillRect(roadX, 0, roadWidth, canvas.height);
        drawRoadMarkings();

        // Traffic
        traffic.forEach(car => {
            const carX = roadX + (car.lane * laneWidth) + (laneWidth/2);
            drawCar(carX, car.y, car.color);
        });

        // Obstacles
        drawObstacles();

        // Player
        drawCar(currentX, playerY, selectedColor, true);
    }

    function drawRoadMarkings() {
       ctx.strokeStyle = "#f1c40f"; ctx.lineWidth = 4;
       ctx.beginPath(); ctx.moveTo(roadX,0); ctx.lineTo(roadX,canvas.height); ctx.stroke();
       ctx.beginPath(); ctx.moveTo(roadX+roadWidth,0); ctx.lineTo(roadX+roadWidth,canvas.height); ctx.stroke();

       ctx.strokeStyle = "#ecf0f1"; ctx.setLineDash([40, 50]); ctx.lineWidth = 3;
       const lineOffset = (Date.now() / 2.5) % 90; 
       ctx.lineDashOffset = -lineOffset;

       ctx.beginPath(); ctx.moveTo(roadX + laneWidth, 0); ctx.lineTo(roadX + laneWidth, canvas.height); ctx.stroke();
       ctx.beginPath(); ctx.moveTo(roadX + laneWidth * 2, 0); ctx.lineTo(roadX + laneWidth * 2, canvas.height); ctx.stroke();
       ctx.setLineDash([]);
    }

    function drawObstacles() {
        ctx.textAlign = "center"; ctx.textBaseline = "middle";
        const time = Date.now();

        obstacles.forEach(obs => {
            if (obs.y > -200 && obs.y < canvas.height + 100 && !obs.passed) {
                const obsX = roadX + (obs.lane * laneWidth) + (laneWidth/2);
                
                // Star
                const floatY = Math.sin(time / 200) * 10;
                drawStar(obsX, obs.y - 65 + floatY, 5, 20, 10);

                // Card
                ctx.fillStyle = "rgba(255,255,255,0.95)";
                ctx.beginPath(); ctx.roundRect(obsX - 50, obs.y - 25, 100, 50, 10); ctx.fill();
                
                // Text
                ctx.fillStyle = "#2c3e50"; ctx.font = "900 26px 'Microsoft JhengHei'";
                ctx.fillText(obs.word, obsX, obs.y + 2);
            }
        });
    }

    function drawStar(cx, cy, spikes, outerRadius, innerRadius) {
        let rot = Math.PI / 2 * 3;
        let x = cx, y = cy;
        let step = Math.PI / spikes;

        ctx.beginPath();
        ctx.moveTo(cx, cy - outerRadius);
        for (let i = 0; i < spikes; i++) {
            x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius; ctx.lineTo(x, y); rot += step;
            x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius; ctx.lineTo(x, y); rot += step;
        }
        ctx.lineTo(cx, cy - outerRadius);
        ctx.closePath();
        ctx.fillStyle = "#FFD700"; ctx.fill();
        ctx.strokeStyle = "#F39C12"; ctx.lineWidth = 2; ctx.stroke();
    }

    function drawCar(x, y, color, isPlayer = false) {
        ctx.save();
        ctx.translate(x, y);
        
        ctx.fillStyle = "rgba(0,0,0,0.4)"; // Shadow
        ctx.beginPath(); ctx.ellipse(0, 5, 30, 55, 0, 0, Math.PI * 2); ctx.fill();

        ctx.fillStyle = "#222"; // Wheels
        const wPos = [[-26,-30], [18,-30], [-26,15], [18,15]];
        wPos.forEach(p => { ctx.beginPath(); ctx.roundRect(p[0], p[1], 8, 18, 4); ctx.fill(); });

        ctx.fillStyle = color; // Body
        ctx.beginPath(); ctx.roundRect(-22, -45, 44, 90, 12); ctx.fill();

        ctx.fillStyle = "rgba(0,0,0,0.2)"; // Cabin
        ctx.beginPath(); ctx.roundRect(-17, -28, 34, 45, 8); ctx.fill();

        ctx.fillStyle = "#4a6b8c"; // Windshield
        ctx.beginPath(); ctx.roundRect(-15, -25, 30, 18, 5); ctx.fill();
        
        ctx.fillStyle = color; // Roof
        ctx.beginPath(); ctx.roundRect(-16, -8, 32, 24, 6); ctx.fill();

        ctx.fillStyle = "#333"; // Rear Window
        ctx.beginPath(); ctx.roundRect(-14, 16, 28, 6, 2); ctx.fill();

        if (isPlayer) {
             ctx.fillStyle = "#e74c3c"; // Tail lights
             ctx.fillRect(-18, 42, 8, 4); ctx.fillRect(10, 42, 8, 4);
        }
        ctx.restore();
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function playSound(type) {
        if (!audioCtx) return;
        if (audioCtx.state === 'suspended') audioCtx.resume();
        
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.connect(gain);
        gain.connect(audioCtx.destination);

        if (type === 'ding') {
            osc.type = 'sine';
            osc.frequency.setValueAtTime(660, audioCtx.currentTime); 
            osc.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.1);
            gain.gain.setValueAtTime(0, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.6);
            osc.start(); osc.stop(audioCtx.currentTime + 0.6);
        } else if (type === 'crash') {
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(150, audioCtx.currentTime); 
            osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.4, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
            osc.start(); osc.stop(audioCtx.currentTime + 0.3);
        }
    }

    function isTouchDevice() {
        return (('ontouchstart' in window) || (navigator.maxTouchPoints > 0));
    }

    window.addEventListener('keydown', (e) => {
        if (gameState === 'PLAYING') {
            if (['a', 'A', 'ArrowLeft'].includes(e.key) && playerLane > 0) playerLane--;
            if (['d', 'D', 'ArrowRight'].includes(e.key) && playerLane < 2) playerLane++;
        } else if (gameState === 'STOPPED') {
            if (['Enter', ' '].includes(e.key)) resumeGame(true);
        }
    });

    document.getElementById('therapist-btn').addEventListener('click', (e) => {
        e.preventDefault(); resumeGame(true);
    });

    let touchStartX = 0;
    window.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
    }, {passive: false});

    window.addEventListener('touchend', (e) => {
        if (gameState !== 'PLAYING') return;
        const touchEndX = e.changedTouches[0].screenX;
        if (touchEndX < touchStartX - 50 && playerLane > 0) playerLane--;
        else if (touchEndX > touchStartX + 50 && playerLane < 2) playerLane++;
    }, {passive: false});

</script>
</body>
</html>

